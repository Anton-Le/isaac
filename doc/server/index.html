<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<style>
  html * {
     max-width: 1280px !important;
  }
</style>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>ISAAC: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doc_search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<style>
  .title-margin {
     padding-bottom: 5mm;
     padding-top: 5mm;
  }
</style>
</head>
<font face="arial" size="4">
<body style="margin: auto;font-family: Arial !important;">
<img src="../../isaac.svg" alt="ISAAC" height="100" align="middle" style="float:left;"/>
<div class="title-margin">
<font size="6">
<a href="../../index.html">Overview</a> :: <a href="../library/index.html">Library Doc</a> :: <a href="../server/index.html">Server Doc</a> :: <a href="../json/index.html">JSON Commands</a>
</font>
</div>
</font>
<h1>In Situ Animation of Accelerated Computations</h1>
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">ISAAC Server Documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This documentation is mainly for code documentation, especially to extent the server for your needs. However this main page will also give some hints how to use the server.</p>
<h1><a class="anchor" id="install_sec"></a>
Installation</h1>
<p>For hints how to install the server please have a look the <a href="https://github.com/ComputationalRadiationPhysics/isaac/blob/master/INSTALL.md">INSTALL.MD</a> documentation. This also explains the requirements to use the ISAAC server.</p>
<h1><a class="anchor" id="using_sec"></a>
Using the ISAAC server</h1>
<p>After building the ISAAC server you should have an "isaac" binary, which you can run with &ndash;help to get an overview of the possible options: </p><pre>
$ ./isaac --help
ISAAC - In Situ Animation of Accelerated Computations 1.0
Usage:
isaac [--help] [--web_port &lt;X&gt;] [--sim_port &lt;X&gt;] [--url &lt;X&gt;] [--name &lt;X&gt;]
      [--jpeg] [--version]
       --help: Shows this help
   --web_port: Set port for the websocket clients to connect. Default 2459
   --tcp_port: Set port for the tcp clients to connect. Default 2458
   --sim_port: Set port for the simulations to connect to. Default 2460
        --url: Set the url to connect to from outside. Default 127.0.0.1
       --name: Set the name of the server.
    --version: Shows the version
     --twitch: Set twitch apikey for twitch live streaming
 --twitch_url: Set twitch rtmp-url for ssh forwarding or another rtmp service
--twitch_bitrate: Set twitch bitrate. Default 400
</pre><table class="doxtable">
<caption align="bottom">Server parameters</caption>
<tr>
<th>Option </th><th>Comments  </th></tr>
<tr>
<td><pre>--help</pre> </td><td>Shows the help above  </td></tr>
<tr>
<td><pre>--web_port</pre><pre>--tcp_port</pre><pre>--sim_port</pre> </td><td>The server listens on three ports for incoming connections. The port given by web_port is the port the a websocket (html5) client is using. The tcp_port can be used for a future client using tcp instead of websockets. You can connect via telnet to this port and getting and sending json messages yourself "by hand". The sim_port is the port the simulation tries to connect to. It makes sense to change the default values if you need to run more than more instance of isaac on the same server for some reasons.  </td></tr>
<tr>
<td><pre>--url</pre> </td><td>The url, which is broadcastet for some kind of streams to the clients. So this should be an url, which resolves to the computer the server is running on.  </td></tr>
<tr>
<td><pre>--name</pre> </td><td>The name of the server, which is broadcastet to clients, too.  </td></tr>
<tr>
<td><pre>--version</pre> </td><td>Returns the version of ISAAC.  </td></tr>
<tr>
<td><pre>--twitch</pre> </td><td>Activates streaming to an RTMP service. The Twitch™ url is default and it was first introduced for Twitch™, but it does also work with other RTMP services like Youtube™. You need to pass your session/api key after this command!  </td></tr>
<tr>
<td><pre>--twitch_url</pre> </td><td>To use another RTMP service than Twitch™ or a more close Twitch™ server you can specify another one here. For Youtube™ you would e.g. use <code>&ndash;twitch_url a.rtmp.youtube.com/live2.</code>  </td></tr>
<tr>
<td><pre>--twitch_bitrate</pre> </td><td>At default only a bitrate around 400 KBit/s is used, which is around the upstream speed of a 16 MBit DSL connection. However on high performance clusters the upstream is normally much higher, so a value around 2000 - or even more - creates way better streams.  </td></tr>
</table>
<h1><a class="anchor" id="upgrade_sec"></a>
Extending the ISAAC Server</h1>
<p>This section is interesting for people, who want to add a new streaming possibility to ISAAC or another way of connecting for clients.</p>
<h2><a class="anchor" id="upgrade_connection_sec"></a>
Adding a new meta data connection</h2>
<p>At the moment it is possible for websockets or pure tcp sockets to connect to the ISAAC Server. If you need another way of communicating, you just need to implement the abstract class <a class="el" href="classMetaDataConnector.html">MetaDataConnector</a>. You need to overwrite three methods: </p><ul>
<li>
<a class="el" href="classMetaDataConnector.html#a3130223fa0425924d5659d8932412e46">MetaDataConnector::init</a> </li>
<li>
<a class="el" href="classMetaDataConnector.html#afc69245cb62425dd938c0a517cb29297">MetaDataConnector::run</a> </li>
<li>
<a class="el" href="classMetaDataConnector.html#ac9b59babfad2d71ff2d6a54471b5424f">MetaDataConnector::getName</a> </li>
</ul>
<p><a class="el" href="classMetaDataConnector.html#a3130223fa0425924d5659d8932412e46">MetaDataConnector::init</a> gets a port as parameter. If your connector is not network based you can ignore this parameter. This function is called once at the beginning in the <a href="isaac_8cpp_source.html"><b>isaac.cpp</b></a>. However you need to add your connector in this file yourself, so that the server is able to connect to your class.</p>
<p><a class="el" href="classMetaDataConnector.html#afc69245cb62425dd938c0a517cb29297">MetaDataConnector::run</a> is run as own thread in the background right after the init of the class. It is your tasks to wait for messages for connecting clients and to send them to them, but also to tell the ISAAC Server about new connections and incoming messages from them.</p>
<p><a class="el" href="classMetaDataConnector.html#ac9b59babfad2d71ff2d6a54471b5424f">MetaDataConnector::getName</a> just needs to return a <code>std::string</code> with the name of the connector.</p>
<p><a class="el" href="classMetaDataConnector.html">MetaDataConnector</a> inherits from <a class="el" href="classMessageAble.html">MessageAble&lt;MessageContainer&gt;</a> to be able to send and receive interprocess messages to and from the main thread (called <a class="el" href="classBroker.html">Broker</a>). It defines four methods, but you <b>have to</b> only use these: </p><ul>
<li>
<a class="el" href="classMessageAble.html#a323c572ceafff3f98f4a472005c40ac0">MessageAble&lt;MessageContainer&gt;::clientGetMessage</a> </li>
<li>
<a class="el" href="classMessageAble.html#a44ce5680113f438e59630b185d2913fa">MessageAble&lt;MessageContainer&gt;::clientSendMessage</a> </li>
</ul>
<p>However at the moment, the server does not react to messages from a <a class="el" href="classMetaDataConnector.html">MetaDataConnector</a>, so in fact only <a class="el" href="classMessageAble.html#a323c572ceafff3f98f4a472005c40ac0">MessageAble&lt;MessageContainer&gt;::clientGetMessage</a> is important for you. The run method needs to check for new messages from the server with <code>clientGetMessage</code> all the time. A <a class="el" href="classMessageContainer.html">MessageContainer</a> is returned. This container has 3 attributs </p><ul>
<li>
<a class="el" href="classMessageContainer.html#a704b8e97ab929db7d87fbefae314df4f">MessageContainer::type</a> from type MessageType shows the type of the message for fast reacting and without the need to parse every json package. </li>
<li>
<a class="el" href="classMessageContainer.html#a841079681e7ebda39525350fb14ffc34">MessageContainer::json_root</a> is the body of the message from type <code>json_t*</code>. This is a Jansson object. Have a look at the <a href="https://jansson.readthedocs.org/">awesome Jansson documentation</a> for details how to access the json data. </li>
<li>
<a class="el" href="classMessageContainer.html#af863233638e09ddfc11e7c650fb4c0e4">MessageContainer::drop_able</a> tells you, whether it is okay to drop the message and not to send it to the client. This is useful if you noticed, that your used channel is full (e.g. too slow network connection). </li>
</ul>
<p>At the moment the only important message type for you is <code>FORCE_EXIT</code>, which means you need to exit your run method. After parsing the message you <b>have to</b> delete the object!</p>
<p>If you got a connection from a client you need to tell the ISAAC <a class="el" href="classBroker.html">Broker</a> to add a new client with <code>broker-&gt;addDataClient()</code>. You need to store the returned MetaDataClient* object yourself and to couple it with the just established client connection. Later if messages from the client arrive or you need to send messages to it, you need to use <code>client-&gt;clientGetMessage()</code> and <code>client-&gt;clientSendMessage( … )</code> which work the very same as your own <code>clientSendMessage</code> and <code>clientGetMessage methods</code> - they even use the same <a class="el" href="classMessageContainer.html">MessageContainer</a> object. To create a new <a class="el" href="classMessageContainer.html">MessageContainer</a> object to send it to the server just call the constructor with the three above mentioned attributes as parameters. The <code>json_t*</code> object you need to create yourself with the Jansson API. If you received and forwarded a message to a connected client it is <b>your task</b> to delete the MessageContainer* object!</p>
<p>For a deeper insight have a look at the implementations of <a href="TCPDataConnector_8cpp_source.html"><b>TCPDataConnector.cpp</b></a> and <a href="WebSocketDataConnector_8cpp_source.html"><b>WebSocketDataConnector.cpp</b></a>.</p>
<h2><a class="anchor" id="upgrade_image_sec"></a>
Adding a new image connector</h2>
<p>This works quite the same as with the meta data connector, but you need to inherit from <a class="el" href="classImageConnector.html">ImageConnector</a> and instead of the <a class="el" href="classMessageContainer.html">MessageContainer</a> a <a class="el" href="classImageBufferContainer.html">ImageBufferContainer</a> is sent to and from your class. You still need to overwrite an <code>init</code>, <code>run</code> and <code>getName</code> method. However the <code>init</code> method now has two parameters <code>min_port</code> and <code>max_port</code>, which define the range, in which you may open connections to send data. Furthermore there is a new attribute <a class="el" href="classImageConnector.html#ab65159785258624072bfea2b5020a6fa">ImageConnector::showClient</a>, which tells ISAAC, whether a client should be told about your connector or not. The Twitch™ plugin uses this, as always the first connected visualization is broadcastet to an RTMP server - independent, what stream the client chose. You still need to add your class to <a href="isaac_8cpp_source.html"><b>isaac.cpp</b></a> yourself.</p>
<p>The attributes of <a class="el" href="classImageBufferContainer.html">ImageBufferContainer</a> are </p><ul>
<li>
<a class="el" href="classImageBufferContainer.html#ab9db7103309da688eec1cb7ee0bbc83a">ImageBufferContainer::type</a>, which works very much like <a class="el" href="classMessageContainer.html#a704b8e97ab929db7d87fbefae314df4f">MessageContainer::type</a>, but defines different values. </li>
<li>
<a class="el" href="classImageBufferContainer.html#adcab864c692649db57baa61806514fbe">ImageBufferContainer::group</a>, which is an unique identifier (pointer) to the visualization (called "group" because it consits of many distributed applications running on the high performance cluster). This is valid as long as the group was not told to be finished! Afterwards a new <b>different</b> group could get the same pointer. </li>
<li>
<a class="el" href="classImageBufferContainer.html#afef234c03b36122dc6a5aaae77c083dd">ImageBufferContainer::reference</a> is a unique reference (pointer) to the client, to which you stream. </li>
<li>
<a class="el" href="classImageBufferContainer.html#aa7063d9a4a73d1aeb8033f580947acd8">ImageBufferContainer::target</a> is where the stream should be send to. This is important for protocols like RTP, which send streams to an address without a back channel. </li>
<li>
<a class="el" href="classImageBufferContainer.html#af0a35e511d50420020a206a6de5eb019">ImageBufferContainer::image</a> is an <a class="el" href="classImageBuffer.html">ImageBuffer</a> * object, which contains the image itself to stream. </li>
<li>
<a class="el" href="classImageBufferContainer.html#a7c844f4e2f5ac2de77c4489b2607c47a">ImageBufferContainer::ref_count</a> is a reference count for the object. To not copy the images, one copy of <a class="el" href="classImageBufferContainer.html">ImageBufferContainer</a> is used for all <a class="el" href="classImageConnector.html">ImageConnector</a> implementations. Not very important for a <a class="el" href="classImageConnector.html">ImageConnector</a> implementation. </li>
<li>
<a class="el" href="classImageBufferContainer.html#a7ca60f5eb98f03c48c7a346ed9aafb50">ImageBufferContainer::json</a> and <a class="el" href="classImageBufferContainer.html#a231ce23af757f3e974c1d740bc16b8f3">ImageBufferContainer::payload</a> are two <code>json_t*</code> objects, which contain the general meta data for the image, but also the image self as base64 string in <code>payload</code>. Do not change these without the mutexes below! </li>
<li>
<a class="el" href="classImageBufferContainer.html#a680467b40763de6da89660b62986b9a5">ImageBufferContainer::json_mutex</a> and <a class="el" href="classImageBufferContainer.html#a0d2a8a53602af2c5336fd496cabedf15">ImageBufferContainer::payload_mutex</a> are <a href="https://computing.llnl.gov/tutorials/pthreads/">pthread</a> mutexes, which you <b>have to lock</b> if you want to read or write to the <code>json_t*</code> objects above. <a class="el" href="classURIImageConnector.html">URIImageConnector</a> uses this to add the image directly to the meta data package instead of streaming it on an extra channel. But you could also add some extra meta data of your stream or only extract meta data from the image and add it to the json object instead of creating a stream at all. The sky's the limit! </li>
</ul>
<p>There are also some differences in the behaviour (besides the other container). You do not establish a client specific connection yourself, but get told from the server with <code>message-&gt;type == <b>GROUP_OBSERVED</b></code>, that a client chose your stream and wants to see something. If a client stopped observing you get a message from type <b><code>GROUP_OBSERVED_STOPPED</code></b> and if the visualization/simulation stopped you get <b><code>GROUP_FINISHED</code></b>. If you get <b><code>IMG_FORCE_EXIT</code></b> you need to exit your loop. Don't forget to close the streams before.</p>
<p>The most interesting message is surely <b><code>UPDATE_BUFFER</code></b>, which means a new image is available. You can read it directly from the image object with <code>image-&gt;buffer</code>. It is RGBx formated byte-streams, which means 4 bytes are one pixel: the first byte is red, the second blue, the third green and the last one just reserved without useful data. To get the size of the image use <a class="el" href="classImageBufferContainer.html#adcab864c692649db57baa61806514fbe">ImageBufferContainer::group</a> with <code>message-&gt;group-&gt;getFramebufferWidth()</code> and <code>message-&gt;group-&gt;getFramebufferHeight()</code>. The image object itself has a reference counter, too. You should not delete the image object at the end, but if you want to start an extra thread for processing the image, it may happen, that the image gets freed in the main thread while you access it. To avoid this you can increase the reference counter yourself with <code>image-&gt;incref();</code>, but afterwards you have to call <code>image-&gt;suicide();</code> in the <b>extra thread</b> processing the image to check the reference counter and to delete the image if it is not in use anymore. <b>Don't</b> call <code>delete image</code> yourself!</p>
<p>Another important difference to the <a class="el" href="classMetaDataConnector.html">MetaDataConnector</a> is, that you never delete received messages, but send them back to the <a class="el" href="classBroker.html">Broker</a> with <code>clientSendMessage( message );</code>. The flow of the ISAAC Server is: </p><ul>
<li>
<a class="el" href="classBroker.html">Broker</a> gets a message from a isaac lib instance in a visualization. </li>
<li>
<a class="el" href="classBroker.html">Broker</a> extracts the image and sends it to <b>every</b> <a class="el" href="classImageConnector.html">ImageConnector</a>. </li>
<li>
<a class="el" href="classImageConnector.html">ImageConnector</a>s check, whether they need to handle the message, but send it back <b>in any case</b>, even if they didn't touch at all! </li>
<li>
<a class="el" href="classBroker.html">Broker</a> receives the "answers" from the <a class="el" href="classImageConnector.html">ImageConnector</a>s, maybe the json object got new content. If all answers are received, a <a class="el" href="classMessageContainer.html">MessageContainer</a> is send to all observing clients. </li>
<li>
<a class="el" href="classMetaDataConnector.html">MetaDataConnector</a>s check for new messages for their clients, get the message from the <a class="el" href="classBroker.html">Broker</a> and forward them. </li>
</ul>
<p>For a deeper insight have a look at the implementations of </p><ul>
<li>
<a href="RTPImageConnector_8cpp_source.html"><b>RTPImageConnector.cpp</b></a>, which creates RTP streams, </li>
<li>
<a href="RTMPImageConnector_8cpp_source.html"><b>RTMPImageConnector.cpp</b></a>, which creates RTMP streams (e.g. for Twitch™ and Youtube™) for the very first visualization registered at the server, </li>
<li>
<a href="SDLImageConnector_8cpp_source.html"><b>SDLImageConnector.cpp</b></a>, which creates a window on the same server for the very first visualization registered at the server (mainly for debugging reasons), </li>
<li>
<a href="URIImageConnector_8cpp_source.html"><b>URIImageConnector.cpp</b></a>, which (re)adds the image as base64 string to the json object and sends it directly to the observing clients. </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 7 2016 15:34:41 for ISAAC Server by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
